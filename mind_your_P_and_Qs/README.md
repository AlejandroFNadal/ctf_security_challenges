https://play.picoctf.org/practice/challenge/162

Let's get the data:

wget https://mercury.picoctf.net/static/b9ddda080c56fb421bf30409bec3460d/values

First, lets see the file. It contains three lines, one for c, another for n, and another for e. This are elements of common descriptions of RSA. Also, the challenge and the file already mention RSA. 

RSA takes two prime numbers, multiplies them and produces n. We, of course, dont have these two values. 

This number is not prime, which doesnt say much, but if it were prime it could not be n, as n is generated by the multiplication of two prime numbers in RSA.

Then, we have e, which should be coprime of n. e is 65537. This page gives us the divisors of n. None of these include the divisors of 65537, so they are coprime. https://www.alpertron.com.ar/ECM.HTM .This is also a good sign.

With RSA, the cipher text c will be generated as:

c = (plain_text ** e ) % n

A public key, thus, is composed of (n, e)
And a private key is composed of (n, d)

To create d, you take two prime numbers, p and q. These numbers are multiplied and then you get n. 

Then, you calculate phi = (p-1)*(q-1)

And then, e and phi go through a process called modular multiplicative inverse, in which the extended euclidean algorithm is applied. I got this sectionfrom the internet and the math, specially the notation used for it, can be quite complex. Essentially though, you first find x and y for the following equation:

ax + by = gcd(a,b) where gcd is the greatest common denominator of the exponent and phi.

Then, you calculate the modulus of a and e. If you want to go through the algorithm of the equation shown before, you can look the Extended Euclidean Algorithm. 

Finally, this value will give us d. Why d is important?

Because to decipher, you need to do the following:

deciphered_text = (c ** d) % n

Usually, the strength of this algorithm lies on the fact that it is incredibly hard to get the values of p and q for long n values. But this n value is quite short, and the page I mentioned before can factorize it in a pair of minutes, giving us p and q. 

In analyze_script.py this is shown in detail. Finally, we transform the resulting value into hexadecimal, and then take every byte and convert it into ascii. This will yield the flag.
